> 🎗 本文节选自 [Web 开发导论/微前端与大前端](https://parg.co/oyv)，着眼阐述了微服务与微前端的设计理念以及微前端的潜在可行方案，需要致敬的是，本文的很多考虑借鉴了 [Phodal 关于微前端的系列讨论](https://www.phodal.com/blog)以及 [Web Architecture Links](https://parg.co/oym) 中声明的其他文章，此外结合了自己浅薄的考量与实践体悟，框架代码可以参阅 [Ueact/micro-frontend](https://github.com/wx-chevalier/Ueact)。

# 微前端

所谓微前端，即是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。微服务与微前端，都是希望将某个单一的单体应用，转化为多个可以独立运行、独立开发、独立部署、独立维护的服务或者应用的聚合，从而满足业务快速变化及分布式多团队并行开发的需求，并且保证仍然聚合为一个产品出现在客户面前。如康威定律(Conway’s Law)所言，任何组织在设计一套系统（广义概念）时，所交付的设计方案在结构上都与该组织的通信结构保持一致；微服务与微前端不仅仅是技术架构的变化，还包含了组织方式、沟通方式的变化。微服务与微前端原理和软件工程，面向对象设计中的原理同样相通，都是遵循单一职责(Single Responsibility)、关注分离(Separation of Concerns)、模块化(Modularity)与分而治之(Divide & Conquer)等基本的原则。

![image](https://user-images.githubusercontent.com/5803001/44003132-9ecc01b2-9e80-11e8-9418-a98cddac88d7.png)

在某些场景下，微前端也包含了对于系统的纵向切分；即不同的团队会负责系统中某个特性/模块，从数据库、服务端到用户界面完整的流线。每个团队会更多地着眼于业务模型与特点。独立并不意味着完全的切割，各个特性/模块之间的共现组件可以通过 NPM/Git Submodule/Dynamic Load/Module Federation 等方式进行协同开发与复用。值得留意的几个点：

- 微前端不是一门具体的技术，而是整合了技术、策略和方法，可能会以脚手架、辅助插件和规范约束这种生态圈形式展示出来，是一种宏观上的架构。这种架构目前有多种方案，都有利弊之处，但只要适用当前业务场景的就是好方案。
- 微前端并没有技术栈的约束。每一套微前端方案的设计，都是基于实际需求出发。如果是多团队统一使用了 react 技术栈，可能对微前端方案的跨技术栈使用并没有要求；如果是多团队同时使用了 react 和 vue 技术栈，可能就对微前端的跨技术栈要求比较高。

# 微前端特性

假设要做一个食品外卖的网站。乍一看这种网站好像很好做，但想要做好需要在诸多细节上下足功夫：

- 应该有一个引导页面，让顾客浏览并搜索餐馆。顾客应该能按照一系列参数（包括价格、菜品或订购历史等）来搜索并过滤餐馆。
- 每家餐馆都要有自己的页面，页面中要展示菜单，允许客户自主选餐，还要有折扣、套餐和特殊要求选项。
- 顾客应该有自己的主页，可以用来查看订单历史、跟踪外卖进度并自定义付款选项

![](https://tva1.sinaimg.cn/large/007DFXDhgy1g44gooc5m6j30hs0ast9r.jpg)

每个页面都非常复杂，都应该分配一个专门团队来负责，并且每个团队都应该有足够的独立性。各个团队都应该能独立开发、测试、部署和维护自己的代码，而不会与其他团队发生冲突或需要其他团队配合。但在客户这里，整个网站仍然应该是一个无缝的整体。

![](https://tva1.sinaimg.cn/large/007DFXDhgy1g44gqr6d2kj30no0asjsq.jpg)

## 增量升级

对于许多组织来说，追求增量升级就是他们迈向微前端的第一步。对他们来说，老式的大型单体前端要么是用老旧的技术栈打造的，要么就充斥着匆忙写成的代码，已经到了该重写整个前端的时候了。一次性重写整个系统风险很大，我们更倾向一点一点换掉老的应用，同时在不受单体架构拖累的前提下为客户不断提供新功能。

为了做到这一点，解决方案往往就是微前端架构了。一旦某个团队掌握了在几乎不影响旧世界的同时为生产环境引入新功能的诀窍，其他团队就会纷纷效仿。现有代码仍然需要继续维护下去，但在某些情况下还要继续添加新功能，现在总算有了解决方案。

到最后，我们就能更随心所欲地改动产品的各个部分，并逐渐升级我们的架构、依赖关系和用户体验。当主框架发生重大变化时每个微前端模块都可以按需升级，不需要整体下线或一次性升级所有内容。如果我们想要尝试新的技术或互动模式，也能在隔离度更好的环境下做试验。

## 简洁、解耦的代码库

微前端体系下，每个小模块的代码库要比一个单体前端的代码库小很多。对开发者来说这些较小的代码库处理起来更简单方便。而且微前端还能避免无关组件之间不必要的耦合，让代码更简洁。我们可以在应用的限界上下文（详见下方链接）处划出更明显的界限，更好地避免无意间造成的这类耦合问题。

当然，只靠架构更迭本身（比如说“我们改成微前端吧”）并不能自动为以往的优质代码生成替代品。我们要做的是设法让糟糕的决策难以露头，而让正确的决策畅通无阻，从而进入迈向成功的良性循环。例如，现在很难跨越限界上下文共享域模型，所以开发者就不太可能这样做了。类似地，微前端会让开发者更审慎地把握数据和事件在应用的各个部分之间流动的方式，其实就算没有微前端我们本来也应该这样做的！

## 独立部署

就像微服务一样，微前端的一大优势就是可独立部署的能力。这种能力会缩减每次部署涉及的范围，从而降低了风险。不管你的前端代码是在哪里托管，怎样托管，各个微前端都应该有自己的持续交付管道；这些管道可以将微前端构建、测试并部署到生产环境中。我们在部署各个微前端时几乎不用考虑其他代码库或管道的状态；就算旧的单体架构采用了固定、手动的按季发布周期，或者隔壁的团队在他们的主分支里塞进了一个半成品或失败的功能，也不影响我们的工作。如果某个微前端已准备好投入生产，那么它就能顺利变为产品，且这一过程完全由开发和维护它的团队主导。

![](https://tva1.sinaimg.cn/large/007DFXDhgy1g44glrhovcj30sy09qjsk.jpg)

## 自治团队

解藕代码库、分离发布周期还能带来一个高层次的好处，那就是大幅提升团队的独立性；一支独立的团队可以自主完成从产品构思到最终发布的完整流程，有足够的能力独立向客户交付价值，从而可以更快、更高效地工作。为了实现这一目标需要围绕垂直业务功能，而非技术功能来打造团队。一种简单的方法是根据最终用户将看到的内容来划分产品模块，让每个微前端都封装应用的某个页面，并分配给一个团队完整负责。相比围绕技术或“横向”问题（如样式、表单或验证）打造的团队相比，这种团队能有更高的凝聚力。

![](https://tva1.sinaimg.cn/large/007DFXDhgy1g44gm96dwaj30lc0ai75e.jpg)

# 应用架构

微前端的落地，需要考虑到产品研发与发布的完整生命周期；我们会关注如何保证各个团队的独立开发与灵活的技术栈选配，如何保证代码风格、代码规范的一致性，如何合并多个独立的前端应用，如何在运行时对多个应用进行有效治理，如何保障多应用的体验一致性，如何保障个应用的可测试与可依赖性等方面。通常应用中的每个页面都有一个微前端实例，还有一个容器应用，它有以下功能：呈现常见的页面元素，如页眉和页脚；解决了身份认证和跳转等跨领域问题；在页面上集成多个微前端，并告诉各个微前端该何时何地呈现自己。

实际上所有的微前端框架都面临这两大共性问题。当你解决了这两大问题之后，你的微前端框架的运行时，就已经基本可用了。

- 应用的加载与切换。包括路由的处理、应用加载的处理和应用入口的选择。
- 应用的隔离与通信。这是应用已经加载之后面临的问题，它们包括 JS 的隔离（也就是副作用的隔离）、样式的隔离、也包括父子应用和子子应用之间的通信问题。

具体而言，我们可能从应用组合、应用隔离、应用协调与治理、开发环境等几个方面进行考虑：

- 应用集成:

  - 集成时机，在构建时组合，还是在运行时组合；是在服务端组合，还是在客户端组合；
  - 应用路由，如何根据 URL 加载/导航到不同的页面，如何根据子应用界面的变化切换 URL；
  - 应用加载，确定加载应用的版本，依赖于框架的加载机制，还是采用 AMD 或者 SystemJS 异步加载；

- 应用隔离:

  - 应用容错，某个应用的崩溃不应影响到其他应用或容器应用；
  - 样式隔离，避免 CSS 相互污染；
  - DOM 隔离，避免子应用操作非自身作用域内的结点；

- 应用协调与治理：

  - 统一配置与切换，主题，利用 CSS Variables 等方式动态换肤；
  - 应用的生命周期，规范化子应用的生命周期，并且在不同生命周期中执行不同的操作；
  - 数据共享，子应用间数据共享，父子、子子应用间通信；
  - 服务共享，跨应用数据共享与服务调用；
  - 组件共享，可能将某个纯界面组件或者业务组件以插件(Plugin)或者部件(Widget)的方式共享出去；提供某些业务逻辑的计算能力；

- 开发环境：

  - 跨技术栈支持；
  - 统一的构建流程与规范；
  - 打桩、埋点与 Hijack；

此外值得一提的是，微前端化本身是为了保证系统的持续集成与快速迭代，那么对于各个子模块与系统本身的可用性与稳定性势必会带来挑战，这就要求我们在设计微前端解决方案时，考虑持续构建的时机与对应的测试方案；除了标准的单元测试、集成测试、端到端测试之外，我们还需要保证模块的依赖一致性与功能模块的可生成性；关于此部分的详细讨论参阅 [Web 自动化测试概述](https://parg.co/oyu)。

# Links

- https://parg.co/8mt
- https://zhuanlan.zhihu.com/p/78362028
- https://martinfowler.com/articles/micro-frontends.html
- https://mp.weixin.qq.com/s/DVkrV_KKE9KaGSeUSenc6w
